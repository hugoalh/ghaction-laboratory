name: "Test"
on:
  workflow_dispatch:
jobs:
  test:
    name: "Test"
    runs-on: "ubuntu-latest"
    steps:
      - run: |
          enum GitHubActionsAnnotationType {
            E
            Error
            N
            Note
            Notice
            W
            Warn
            Warning
          }
          function Format-GitHubActionsCommand {
            [CmdletBinding()]
            [OutputType([string])]
            param(
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)][AllowEmptyString()][Alias('Input', 'Object')][string]$InputObject,
              [Alias('Properties')][switch]$Property
            )
            begin {}
            process {
              [string]$OutputObject = $InputObject -replace '%', '%25' -replace '\n', '%0A' -replace '\r', '%0D'
              if ($Property) {
                $OutputObject = $OutputObject -replace ',', '%2C' -replace ':', '%3A'
              }
              return $OutputObject
            }
            end {}
          }
          function Write-GitHubActionsCommand {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_write-githubactionscommand#Write-GitHubActionsCommand')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.+$', ErrorMessage = 'GitHub Actions command must be in single line string!')][string]$Command,
              [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true)][Alias('Content')][string]$Message = '',
              [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true)][Alias('Properties')][hashtable]$Property = @{}
            )
            begin {}
            process {
              [string[]]$PropertyResult = $Property.GetEnumerator() | Sort-Object -Property 'Name' | ForEach-Object -Process {
                return "$($_.Name)=$(Format-GitHubActionsCommand -InputObject $_.Value -Property)"
              }
              Write-Host -Object "::$Command$(($PropertyResult.Count -gt 0) ? " $($PropertyResult -join ',')" : '')::$(Format-GitHubActionsCommand -InputObject $Message)"
            }
            end {
              return
            }
          }
          function Add-GitHubActionsEnvironmentVariable {
            [CmdletBinding(DefaultParameterSetName = 'multiple', HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_add-githubactionsenvironmentvariable#Add-GitHubActionsEnvironmentVariable')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, ParameterSetName = 'multiple', Position = 0, ValueFromPipeline = $true)][Alias('Input', 'Object')][hashtable]$InputObject,
              [Parameter(Mandatory = $true, ParameterSetName = 'single', Position = 0, ValueFromPipelineByPropertyName = $true)][ValidatePattern('^(?:[\da-z][\da-z_-]*)?[\da-z]$', ErrorMessage = '`{0}` is not match the require environment variable name pattern!')][Alias('Key')][string]$Name,
              [Parameter(Mandatory = $true, ParameterSetName = 'single', Position = 1, ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.+$', ErrorMessage = 'Environment variable value must be in single line string!')][string]$Value
            )
            begin {
              [hashtable]$Result = @{}
            }
            process {
              switch ($PSCmdlet.ParameterSetName) {
                'multiple' {
                  $InputObject.GetEnumerator() | ForEach-Object -Process {
                    if ($_.Name.GetType().Name -ne 'string') {
                      Write-Error -Message 'Environment variable name must be type of string!' -Category 'InvalidType'
                    } elseif ($_.Name -notmatch '^(?:[\da-z][\da-z_-]*)?[\da-z]$') {
                      Write-Error -Message "``$($_.Name)`` is not match the require environment variable name pattern!" -Category 'SyntaxError'
                    } elseif ($_.Value.GetType().Name -ne 'string') {
                      Write-Error -Message 'Environment variable value must be type of string!' -Category 'InvalidType'
                    } elseif ($_.Value -notmatch '^.+$') {
                      Write-Error -Message 'Environment variable value must be in single line string!' -Category 'SyntaxError'
                    } else {
                      $Result[$_.Name] = $_.Value
                    }
                  }
                  break
                }
                'single' {
                  $Result[$Name] = $Value
                  break
                }
              }
            }
            end {
              if ($Result.Count -gt 0) {
                Add-Content -LiteralPath $env:GITHUB_ENV -Value (($Result.GetEnumerator() | ForEach-Object -Process {
                  return "$($_.Name)=$($_.Value)"
                }) -join "`n") -Confirm:$false -Encoding 'UTF8NoBOM'
              }
              return
            }
          }
          function Add-GitHubActionsPATH {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_add-githubactionspath#Add-GitHubActionsPATH')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.+$', ErrorMessage = 'PATH must be in single line string!')][Alias('Paths')][string[]]$Path,
              [Alias('NoValidate', 'SkipValidate', 'SkipValidator')][switch]$NoValidator
            )
            begin {
              [string[]]$Result = @()
            }
            process {
              $Path | ForEach-Object -Process {
                if (
                  $NoValidator -or
                  (Test-Path -Path $_ -PathType 'Container' -IsValid)
                ) {
                  $Result += $_
                } else {
                  Write-Error -Message "``$_`` is not match the require PATH pattern!" -Category 'SyntaxError'
                }
              }
            }
            end {
              if ($Result.Count -gt 0) {
                Add-Content -LiteralPath $env:GITHUB_PATH -Value ($Result -join "`n") -Confirm:$false -Encoding 'UTF8NoBOM'
              }
              return
            }
          }
          function Add-GitHubActionsProblemMatcher {
            [CmdletBinding(DefaultParameterSetName = 'path', HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_add-githubactionsproblemmatcher#Add-GitHubActionsProblemMatcher')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, ParameterSetName = 'path', Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)][SupportsWildcards()][ValidatePattern('^.+$', ErrorMessage = 'GitHub Actions problem matcher path must be in single line string!')][Alias('File', 'Files', 'Paths')][string[]]$Path,
              [Parameter(Mandatory = $true, ParameterSetName = 'literal-path', ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.+$', ErrorMessage = 'GitHub Actions problem matcher literal path must be in single line string!')][Alias('LiteralFile', 'LiteralFiles', 'LiteralPaths', 'LP', 'PSPath', 'PSPaths')][string[]]$LiteralPath
            )
            begin {}
            process {
              switch ($PSCmdlet.ParameterSetName) {
                'path' {
                  $Path | ForEach-Object -Process {
                    return ([string[]](Resolve-Path -Path $_ -Relative) | Where-Object -FilterScript {
                      return ($null -ne $_ -and $_.Length -gt 0)
                    } | ForEach-Object -Process {
                      return Write-GitHubActionsCommand -Command 'add-matcher' -Message ($_ -replace '^\.[\\\/]', '' -replace '\\', '/')
                    })
                  }
                  break
                }
                'literal-path' {
                  $LiteralPath | ForEach-Object -Process {
                    return Write-GitHubActionsCommand -Command 'add-matcher' -Message ($_ -replace '^\.[\\\/]', '' -replace '\\', '/')
                  }
                  break
                }
              }
            }
            end {
              return
            }
          }
          function Add-GitHubActionsSecretMask {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_add-githubactionssecretmask#Add-GitHubActionsSecretMask')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)][AllowEmptyString()][Alias('Key', 'Secret', 'Token')][string]$Value,
              [Alias('WithChunk')][switch]$WithChunks
            )
            begin {}
            process {
              if ($Value.Length -gt 0) {
                Write-GitHubActionsCommand -Command 'add-mask' -Message $Value
              }
              if ($WithChunks) {
                [string[]]($Value -split '[\b\n\r\s\t_-]+') | ForEach-Object -Process {
                  if ($_ -ne $Value -and $_.Length -gt 2) {
                    Write-GitHubActionsCommand -Command 'add-mask' -Message $_
                  }
                }
              }
            }
            end {
              return
            }
          }
          function Add-GitHubActionsStepSummary {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_add-githubactionsstepsummary#Add-GitHubActionsStepSummary')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)][AllowEmptyCollection()][Alias('Content')][string[]]$Value,
              [switch]$NoNewLine
            )
            begin {
              [string[]]$Result = @()
            }
            process {
              if ($Value.Count -gt 0) {
                $Result += $Value -join "`n"
              }
            }
            end {
              if ($Result.Count -gt 0) {
                Add-Content -LiteralPath $env:GITHUB_STEP_SUMMARY -Value ($Result -join "`n") -Confirm:$false -NoNewline:$NoNewLine -Encoding 'UTF8NoBOM'
              }
              return
            }
          }
          function Disable-GitHubActionsEchoingCommands {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_disable-githubactionsechoingcommands#Disable-GitHubActionsEchoingCommands')]
            [OutputType([void])]
            param()
            return Write-GitHubActionsCommand -Command 'echo' -Message 'off'
          }
          function Disable-GitHubActionsProcessingCommands {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_disable-githubactionsprocessingcommands#Disable-GitHubActionsProcessingCommands')]
            [OutputType([string])]
            param(
              [Parameter(Position = 0)][ValidateScript({
                return ($_ -match '^.+$' -and $_.Length -ge 4 -and $_ -inotin @(
                  'add-mask',
                  'add-matcher',
                  'debug',
                  'echo',
                  'endgroup',
                  'error',
                  'group',
                  'notice',
                  'remove-matcher',
                  'save-state',
                  'set-output',
                  'warning'
                ))
              }, ErrorMessage = 'GitHub Actions disable processing commands end token must be in single line string, more than or equal to 4 characters, not match any GitHub Actions commands, and unique!')][Alias('EndKey', 'EndValue', 'Key', 'Token', 'Value')][string]$EndToken = ((New-Guid).Guid -replace '-', '')
            )
            Write-GitHubActionsCommand -Command 'stop-commands' -Message $EndToken
            return $EndToken
          }
          function Enable-GitHubActionsEchoingCommands {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_enable-githubactionsechoingcommands#Enable-GitHubActionsEchoingCommands')]
            [OutputType([void])]
            param()
            return Write-GitHubActionsCommand -Command 'echo' -Message 'on'
          }
          function Enable-GitHubActionsProcessingCommands {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_enable-githubactionsprocessingcommands#Enable-GitHubActionsProcessingCommands')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, Position = 0)][ValidateScript({
                return ($_ -match '^.+$' -and $_.Length -ge 4 -and $_ -inotin @(
                  'add-mask',
                  'add-matcher',
                  'debug',
                  'echo',
                  'endgroup',
                  'error',
                  'group',
                  'notice',
                  'remove-matcher',
                  'save-state',
                  'set-output',
                  'warning'
                ))
              }, ErrorMessage = 'GitHub Actions enable processing commands end token must be in single line string, more than or equal to 4 characters, and not match any GitHub Actions commands!')][Alias('EndKey', 'EndValue', 'Key', 'Token', 'Value')][string]$EndToken
            )
            return Write-GitHubActionsCommand -Command $EndToken
          }
          function Enter-GitHubActionsLogGroup {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_enter-githubactionsloggroup#Enter-GitHubActionsLogGroup')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, Position = 0)][ValidatePattern('^.+$', ErrorMessage = 'GitHub Actions log group title must be in single line string!')][Alias('Header', 'Message')][string]$Title
            )
            return Write-GitHubActionsCommand -Command 'group' -Message $Title
          }
          function Exit-GitHubActionsLogGroup {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_exit-githubactionsloggroup#Exit-GitHubActionsLogGroup')]
            [OutputType([void])]
            param ()
            return Write-GitHubActionsCommand -Command 'endgroup'
          }
          function Get-GitHubActionsInput {
            [CmdletBinding(DefaultParameterSetName = 'one', HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_get-githubactionsinput#Get-GitHubActionsInput')]
            [OutputType([string], ParameterSetName = 'one')]
            [OutputType([hashtable], ParameterSetName = ('all', 'prefix', 'suffix'))]
            param(
              [Parameter(Mandatory = $true, ParameterSetName = 'one', Position = 0, ValueFromPipeline = $true)][ValidatePattern('^(?:[\da-z][\da-z_-]*)?[\da-z]$', ErrorMessage = '`{0}` is not match the require GitHub Actions input name pattern!')][Alias('Key')][string]$Name,
              [Parameter(ParameterSetName = 'one')][Alias('Force', 'Forced', 'Required')][switch]$Require,
              [Parameter(Mandatory = $true, ParameterSetName = 'prefix')][ValidatePattern('^[\da-z][\da-z_-]*$', ErrorMessage = '`{0}` is not match the require GitHub Actions input name prefix pattern!')][Alias('KeyPrefix', 'KeyStartWith', 'NameStartWith', 'Prefix', 'PrefixKey', 'PrefixName', 'StartWith', 'StartWithKey', 'StartWithName')][string]$NamePrefix,
              [Parameter(Mandatory = $true, ParameterSetName = 'suffix')][ValidatePattern('^[\da-z_-]*[\da-z]$', ErrorMessage = '`{0}` is not match the require GitHub Actions input name suffix pattern!')][Alias('EndWith', 'EndWithKey', 'EndWithName', 'KeyEndWith', 'KeySuffix', 'NameEndWith', 'Suffix', 'SuffixKey', 'SuffixName')][string]$NameSuffix,
              [Parameter(ParameterSetName = 'all')][switch]$All,
              [switch]$Trim
            )
            begin {
              [hashtable]$OutputObject = @{}
            }
            process {
              switch ($PSCmdlet.ParameterSetName) {
                'all' {
                  Get-ChildItem -Path 'Env:\INPUT_*' | ForEach-Object -Process {
                    [string]$InputKey = $_.Name -replace '^INPUT_', ''
                    if ($Trim) {
                      $OutputObject[$InputKey] = $_.Value.Trim()
                    } else {
                      $OutputObject[$InputKey] = $_.Value
                    }
                  }
                  break
                }
                'one' {
                  $InputValue = Get-ChildItem -LiteralPath "Env:\INPUT_$($Name.ToUpper())" -ErrorAction 'SilentlyContinue'
                  if ($null -eq $InputValue) {
                    if ($Require) {
                      return Write-GitHubActionsFail -Message "Input ``$Name`` is not defined!"
                    }
                    return $null
                  }
                  if ($Trim) {
                    return $InputValue.Value.Trim()
                  }
                  return $InputValue.Value
                }
                'prefix' {
                  Get-ChildItem -Path "Env:\INPUT_$($NamePrefix.ToUpper())*" | ForEach-Object -Process {
                    [string]$InputKey = $_.Name -replace "^INPUT_$([regex]::Escape($NamePrefix))", ''
                    if ($Trim) {
                      $OutputObject[$InputKey] = $_.Value.Trim()
                    } else {
                      $OutputObject[$InputKey] = $_.Value
                    }
                  }
                  break
                }
                'suffix' {
                  Get-ChildItem -Path "Env:\INPUT_*$($NameSuffix.ToUpper())" | ForEach-Object -Process {
                    [string]$InputKey = $_.Name -replace "^INPUT_|$([regex]::Escape($NameSuffix))$", ''
                    if ($Trim) {
                      $OutputObject[$InputKey] = $_.Value.Trim()
                    } else {
                      $OutputObject[$InputKey] = $_.Value
                    }
                  }
                  break
                }
              }
            }
            end {
              if ($PSCmdlet.ParameterSetName -in @('all', 'prefix', 'suffix')) {
                return $OutputObject
              }
            }
          }
          function Get-GitHubActionsIsDebug {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_get-githubactionsisdebug#Get-GitHubActionsIsDebug')]
            [OutputType([bool])]
            param ()
            if ($env:RUNNER_DEBUG -eq 'true') {
              return $true
            }
            return $false
          }
          function Get-GitHubActionsOidcToken {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_get-githubactionsoidctoken#Get-GitHubActionsOidcToken')]
            [OutputType([string])]
            param (
              [Parameter(Position = 0)][AllowNull()][string]$Audience
            )
            [string]$OidcTokenRequestToken = $env:ACTIONS_ID_TOKEN_REQUEST_TOKEN
            [string]$OidcTokenRequestURL = $env:ACTIONS_ID_TOKEN_REQUEST_URL
            if (
              $null -eq $OidcTokenRequestToken -or
              $OidcTokenRequestToken.Length -eq 0
            ) {
              return Write-Error -Message 'Unable to get GitHub Actions OIDC token request token!' -Category 'ResourceUnavailable'
            }
            Add-GitHubActionsSecretMask -Value $OidcTokenRequestToken
            if (
              $null -eq $OidcTokenRequestURL -or
              $OidcTokenRequestURL.Length -eq 0
            ) {
              return Write-Error -Message 'Unable to get GitHub Actions OIDC token request URL!' -Category 'ResourceUnavailable'
            }
            if ($null -ne $Audience -and $Audience.Length -gt 0) {
              Add-GitHubActionsSecretMask -Value $Audience
              [string]$AudienceEncode = [System.Web.HttpUtility]::UrlEncode($Audience)
              Add-GitHubActionsSecretMask -Value $AudienceEncode
              $OidcTokenRequestURL += "&audience=$AudienceEncode"
            }
            try {
              [pscustomobject]$Response = Invoke-WebRequest -Uri $OidcTokenRequestURL -UseBasicParsing -UserAgent 'actions/oidc-client' -Headers @{
                Authorization = "Bearer $OidcTokenRequestToken"
              } -MaximumRedirection 1 -MaximumRetryCount 10 -RetryIntervalSec 10 -Method 'Get'
              [ValidateNotNullOrEmpty()][string]$OidcToken = (ConvertFrom-Json -InputObject $Response.Content -Depth 100).value
              Add-GitHubActionsSecretMask -Value $OidcToken
              return $OidcToken
            } catch {
              return Write-Error @_
            }
          }
          function Get-GitHubActionsState {
            [CmdletBinding(DefaultParameterSetName = 'one', HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_get-githubactionsstate#Get-GitHubActionsState')]
            [OutputType([string], ParameterSetName = 'one')]
            [OutputType([hashtable], ParameterSetName = ('all', 'prefix', 'suffix'))]
            param(
              [Parameter(Mandatory = $true, ParameterSetName = 'one', Position = 0, ValueFromPipeline = $true)][ValidatePattern('^(?:[\da-z][\da-z_-]*)?[\da-z]$', ErrorMessage = '`{0}` is not match the require GitHub Actions state name pattern!')][Alias('Key')][string]$Name,
              [Parameter(Mandatory = $true, ParameterSetName = 'prefix')][ValidatePattern('^[\da-z][\da-z_-]*$', ErrorMessage = '`{0}` is not match the require GitHub Actions state name prefix pattern!')][Alias('KeyPrefix', 'KeyStartWith', 'NameStartWith', 'Prefix', 'PrefixKey', 'PrefixName', 'StartWith', 'StartWithKey', 'StartWithName')][string]$NamePrefix,
              [Parameter(Mandatory = $true, ParameterSetName = 'suffix')][ValidatePattern('^[\da-z_-]*[\da-z]$', ErrorMessage = '`{0}` is not match the require GitHub Actions state name suffix pattern!')][Alias('EndWith', 'EndWithKey', 'EndWithName', 'KeyEndWith', 'KeySuffix', 'NameEndWith', 'Suffix', 'SuffixKey', 'SuffixName')][string]$NameSuffix,
              [Parameter(ParameterSetName = 'all')][switch]$All,
              [switch]$Trim
            )
            begin {
              [hashtable]$OutputObject = @{}
            }
            process {
              switch ($PSCmdlet.ParameterSetName) {
                'all' {
                  Get-ChildItem -Path 'Env:\STATE_*' | ForEach-Object -Process {
                    [string]$StateKey = $_.Name -replace '^STATE_', ''
                    if ($Trim) {
                      $OutputObject[$StateKey] = $_.Value.Trim()
                    } else {
                      $OutputObject[$StateKey] = $_.Value
                    }
                  }
                  break
                }
                'one' {
                  $StateValue = Get-ChildItem -LiteralPath "Env:\STATE_$($Name.ToUpper())" -ErrorAction 'SilentlyContinue'
                  if ($null -eq $StateValue) {
                    return $null
                  }
                  if ($Trim) {
                    return $StateValue.Value.Trim()
                  }
                  return $StateValue.Value
                }
                'prefix' {
                  Get-ChildItem -Path "Env:\STATE_$($NamePrefix.ToUpper())*" | ForEach-Object -Process {
                    [string]$StateKey = $_.Name -replace "^STATE_$([regex]::Escape($NamePrefix))", ''
                    if ($Trim) {
                      $OutputObject[$StateKey] = $_.Value.Trim()
                    } else {
                      $OutputObject[$StateKey] = $_.Value
                    }
                  }
                  break
                }
                'suffix' {
                  Get-ChildItem -Path "Env:\STATE_*$($NameSuffix.ToUpper())" | ForEach-Object -Process {
                    [string]$StateKey = $_.Name -replace "^STATE_|$([regex]::Escape($NameSuffix))$", ''
                    if ($Trim) {
                      $OutputObject[$StateKey] = $_.Value.Trim()
                    } else {
                      $OutputObject[$StateKey] = $_.Value
                    }
                  }
                  break
                }
              }
            }
            end {
              if ($PSCmdlet.ParameterSetName -in @('all', 'prefix', 'suffix')) {
                return $OutputObject
              }
            }
          }
          function Get-GitHubActionsStepSummary {
            [CmdletBinding(DefaultParameterSetName = 'content', HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_get-githubactionsstepsummary#Get-GitHubActionsStepSummary')]
            [OutputType(([string], [string[]]), ParameterSetName = 'content')]
            [OutputType([uint], ParameterSetName = 'sizes')]
            param (
              [Parameter(ParameterSetName = 'content')][switch]$Raw,
              [Parameter(Mandatory = $true, ParameterSetName = 'sizes')][Alias('Size')][switch]$Sizes
            )
            switch ($PSCmdlet.ParameterSetName) {
              'content' {
                return Get-Content -LiteralPath $env:GITHUB_STEP_SUMMARY -Raw:$Raw -Encoding 'UTF8NoBOM'
              }
              'sizes' {
                return (Get-ChildItem -LiteralPath $env:GITHUB_STEP_SUMMARY).Length
              }
            }
          }
          function Get-GitHubActionsWebhookEventPayload {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_get-githubactionswebhookeventpayload#Get-GitHubActionsWebhookEventPayload')]
            [OutputType(([hashtable], [pscustomobject]))]
            param (
              [Alias('ToHashtable')][switch]$AsHashtable,
              [int]$Depth = 1024,
              [switch]$NoEnumerate
            )
            return (Get-Content -LiteralPath $env:GITHUB_EVENT_PATH -Raw -Encoding 'UTF8NoBOM' | ConvertFrom-Json -AsHashtable:$AsHashtable -Depth $Depth -NoEnumerate:$NoEnumerate)
          }
          function Remove-GitHubActionsProblemMatcher {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_remove-githubactionsproblemmatcher#Remove-GitHubActionsProblemMatcher')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)][ValidatePattern('^.+$', ErrorMessage = 'GitHub Actions problem matcher owner must be in single line string!')][Alias('Identifies', 'Identify', 'Identifier', 'Identifiers', 'Key', 'Keys', 'Name', 'Names', 'Owners')][string[]]$Owner
            )
            begin {}
            process {
              $Owner | ForEach-Object -Process {
                return Write-GitHubActionsCommand -Command 'remove-matcher' -Property @{ 'owner' = $_ }
              }
            }
            end {
              return
            }
          }
          function Remove-GitHubActionsStepSummary {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_remove-githubactionsstepsummary#Remove-GitHubActionsStepSummary')]
            [OutputType([void])]
            param ()
            return Remove-Item -LiteralPath $env:GITHUB_STEP_SUMMARY -Confirm:$false
          }
          function Set-GitHubActionsOutput {
            [CmdletBinding(DefaultParameterSetName = 'multiple', HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_set-githubactionsoutput#Set-GitHubActionsOutput')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, ParameterSetName = 'multiple', Position = 0, ValueFromPipeline = $true)][Alias('Input', 'Object')][hashtable]$InputObject,
              [Parameter(Mandatory = $true, ParameterSetName = 'single', Position = 0, ValueFromPipelineByPropertyName = $true)][ValidatePattern('^(?:[\da-z][\da-z_-]*)?[\da-z]$', ErrorMessage = '`{0}` is not match the require GitHub Actions output name pattern!')][Alias('Key')][string]$Name,
              [Parameter(Mandatory = $true, ParameterSetName = 'single', Position = 1, ValueFromPipelineByPropertyName = $true)][AllowEmptyString()][string]$Value
            )
            begin {}
            process {
              switch ($PSCmdlet.ParameterSetName) {
                'multiple' {
                  $InputObject.GetEnumerator() | ForEach-Object -Process {
                    if ($_.Name.GetType().Name -ne 'string') {
                      Write-Error -Message 'GitHub Actions output name must be type of string!' -Category InvalidType
                    } elseif ($_.Name -notmatch '^(?:[\da-z][\da-z_-]*)?[\da-z]$') {
                      Write-Error -Message "``$($_.Name)`` is not match the require GitHub Actions output name pattern!" -Category SyntaxError
                    } elseif ($_.Value.GetType().Name -ne 'string') {
                      Write-Error -Message 'GitHub Actions output value must be type of string!' -Category InvalidType
                    } else {
                      Write-GitHubActionsCommand -Command 'set-output' -Message $_.Value -Property @{ 'name' = $_.Name }
                    }
                  }
                  break
                }
                'single' {
                  Write-GitHubActionsCommand -Command 'set-output' -Message $Value -Property @{ 'name' = $Name }
                  break
                }
              }
            }
            end {
              return
            }
          }
          function Set-GitHubActionsState {
            [CmdletBinding(DefaultParameterSetName = 'multiple', HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_set-githubactionsstate#Set-GitHubActionsState')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, ParameterSetName = 'multiple', Position = 0, ValueFromPipeline = $true)][Alias('Input', 'Object')][hashtable]$InputObject,
              [Parameter(Mandatory = $true, ParameterSetName = 'single', Position = 0, ValueFromPipelineByPropertyName = $true)][ValidatePattern('^(?:[\da-z][\da-z_-]*)?[\da-z]$', ErrorMessage = '`{0}` is not match the require GitHub Actions state name pattern!')][Alias('Key')][string]$Name,
              [Parameter(Mandatory = $true, ParameterSetName = 'single', Position = 1, ValueFromPipelineByPropertyName = $true)][AllowEmptyString()][string]$Value
            )
            begin {}
            process {
              switch ($PSCmdlet.ParameterSetName) {
                'multiple' {
                  $InputObject.GetEnumerator() | ForEach-Object -Process {
                    if ($_.Name.GetType().Name -ne 'string') {
                      Write-Error -Message 'GitHub Actions state name must be type of string!' -Category InvalidType
                    } elseif ($_.Name -notmatch '^(?:[\da-z][\da-z_-]*)?[\da-z]$') {
                      Write-Error -Message "``$($_.Name)`` is not match the require GitHub Actions state name pattern!" -Category SyntaxError
                    } elseif ($_.Value.GetType().Name -ne 'string') {
                      Write-Error -Message 'GitHub Actions state value must be type of string!' -Category InvalidType
                    } else {
                      Write-GitHubActionsCommand -Command 'save-state' -Message $_.Value -Property @{ 'name' = $_.Name }
                    }
                  }
                  break
                }
                'single' {
                  Write-GitHubActionsCommand -Command 'save-state' -Message $Value -Property @{ 'name' = $Name }
                  break
                }
              }
            }
            end {
              return
            }
          }
          function Set-GitHubActionsStepSummary {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_set-githubactionsstepsummary#Set-GitHubActionsStepSummary')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)][AllowEmptyCollection()][Alias('Content')][string[]]$Value,
              [switch]$NoNewLine
            )
            begin {
              [string[]]$Result = @()
            }
            process {
              if ($Value.Count -gt 0) {
                $Result += $Value -join "`n"
              }
            }
            end {
              if ($Result.Count -gt 0) {
                Set-Content -LiteralPath $env:GITHUB_STEP_SUMMARY -Value ($Result -join "`n") -Confirm:$false -NoNewline:$NoNewLine -Encoding 'UTF8NoBOM'
              }
              return
            }
          }
          function Test-GitHubActionsEnvironment {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_test-githubactionsenvironment#Test-GitHubActionsEnvironment')]
            [OutputType([bool])]
            param (
              [Alias('Force', 'Forced', 'Required')][switch]$Require
            )
            if (
              $env:CI -ne 'true' -or
              $null -eq $env:GITHUB_ACTION_REPOSITORY -or
              $null -eq $env:GITHUB_ACTION -or
              $null -eq $env:GITHUB_ACTIONS -or
              $null -eq $env:GITHUB_ACTOR -or
              $null -eq $env:GITHUB_API_URL -or
              $null -eq $env:GITHUB_ENV -or
              $null -eq $env:GITHUB_EVENT_NAME -or
              $null -eq $env:GITHUB_EVENT_PATH -or
              $null -eq $env:GITHUB_GRAPHQL_URL -or
              $null -eq $env:GITHUB_JOB -or
              $null -eq $env:GITHUB_PATH -or
              $null -eq $env:GITHUB_REF_NAME -or
              $null -eq $env:GITHUB_REF_PROTECTED -or
              $null -eq $env:GITHUB_REF_TYPE -or
              $null -eq $env:GITHUB_REPOSITORY_OWNER -or
              $null -eq $env:GITHUB_REPOSITORY -or
              $null -eq $env:GITHUB_RETENTION_DAYS -or
              $null -eq $env:GITHUB_RUN_ATTEMPT -or
              $null -eq $env:GITHUB_RUN_ID -or
              $null -eq $env:GITHUB_RUN_NUMBER -or
              $null -eq $env:GITHUB_SERVER_URL -or
              $null -eq $env:GITHUB_SHA -or
              $null -eq $env:GITHUB_STEP_SUMMARY -or
              $null -eq $env:GITHUB_WORKFLOW -or
              $null -eq $env:GITHUB_WORKSPACE -or
              $null -eq $env:RUNNER_ARCH -or
              $null -eq $env:RUNNER_NAME -or
              $null -eq $env:RUNNER_OS -or
              $null -eq $env:RUNNER_TEMP -or
              $null -eq $env:RUNNER_TOOL_CACHE
            ) {
              if ($Require) {
                return Write-GitHubActionsFail -Message 'This process require to execute inside the GitHub Actions environment!'
              }
              return $false
            }
            return $true
          }
          function Write-GitHubActionsAnnotation {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_write-githubactionsannotation#Write-GitHubActionsAnnotation')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipelineByPropertyName = $true)][GitHubActionsAnnotationType]$Type,
              [Parameter(Mandatory = $true, Position = 1, ValueFromPipelineByPropertyName = $true)][Alias('Content')][string]$Message,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions annotation issue file must be in single line string!')][Alias('Path')][string]$File,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineStart', 'StartLine')][uint]$Line,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('Col', 'ColStart', 'ColumnStart', 'StartCol', 'StartColumn')][uint]$Column,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineEnd')][uint]$EndLine,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('ColEnd', 'ColumnEnd', 'EndCol')][uint]$EndColumn,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions annotation title must be in single line string!')][Alias('Header')][string]$Title
            )
            begin {}
            process {
              [string]$TypeRaw = ''
              switch ($Type) {
                {$_ -match '^e(?:rror)?$'} {
                  $TypeRaw = 'error'
                  break
                }
                {$_ -match '^n(?:ot(?:ic)?e)?$'} {
                  $TypeRaw = 'notice'
                  break
                }
                {$_ -match '^w(?:arn(?:ing)?)?$'} {
                  $TypeRaw = 'warning'
                  break
                }
              }
              [hashtable]$Property = @{}
              if ($File.Length -gt 0) {
                $Property.'file' = $File
              }
              if ($Line -gt 0) {
                $Property.'line' = $Line
              }
              if ($Column -gt 0) {
                $Property.'col' = $Column
              }
              if ($EndLine -gt 0) {
                $Property.'endLine' = $EndLine
              }
              if ($EndColumn -gt 0) {
                $Property.'endColumn' = $EndColumn
              }
              if ($Title.Length -gt 0) {
                $Property.'title' = $Title
              }
              Write-GitHubActionsCommand -Command $TypeRaw -Message $Message -Property $Property
            }
            end {
              return
            }
          }
          function Write-GitHubActionsDebug {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_write-githubactionsdebug#Write-GitHubActionsDebug')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)][Alias('Content')][string]$Message
            )
            begin {}
            process {
              Write-GitHubActionsCommand -Command 'debug' -Message $Message
            }
            end {
              return
            }
          }
          function Write-GitHubActionsError {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_write-githubactionserror#Write-GitHubActionsError')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipelineByPropertyName = $true)][Alias('Content')][string]$Message,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions error annotation issue file must be in single line string!')][Alias('Path')][string]$File,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineStart', 'StartLine')][uint]$Line,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('Col', 'ColStart', 'ColumnStart', 'StartCol', 'StartColumn')][uint]$Column,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineEnd')][uint]$EndLine,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('ColEnd', 'ColumnEnd', 'EndCol')][uint]$EndColumn,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions error annotation title must be in single line string!')][Alias('Header')][string]$Title
            )
            begin {}
            process {
              Write-GitHubActionsAnnotation -Type 'Error' -Message $Message -File $File -Line $Line -Column $Column -EndLine $EndLine -EndColumn $EndColumn -Title $Title
            }
            end {
              return
            }
          }
          function Write-GitHubActionsFail {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_write-githubactionsfail#Write-GitHubActionsFail')]
            [OutputType([void])]
            param(
              [Parameter(Mandatory = $true, Position = 0)][Alias('Content')][string]$Message,
              [ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions error annotation issue file must be in single line string!')][Alias('Path')][string]$File,
              [Alias('LineStart', 'StartLine')][uint]$Line,
              [Alias('Col', 'ColStart', 'ColumnStart', 'StartCol', 'StartColumn')][uint]$Column,
              [Alias('LineEnd')][uint]$EndLine,
              [Alias('ColEnd', 'ColumnEnd', 'EndCol')][uint]$EndColumn,
              [ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions error annotation title must be in single line string!')][Alias('Header')][string]$Title
            )
            Write-GitHubActionsAnnotation -Type 'Error' -Message $Message -File $File -Line $Line -Column $Column -EndLine $EndLine -EndColumn $EndColumn -Title $Title
            exit 1
          }
          function Write-GitHubActionsNotice {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_write-githubactionsnotice#Write-GitHubActionsNotice')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipelineByPropertyName = $true)][Alias('Content')][string]$Message,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions notice annotation issue file must be in single line string!')][Alias('Path')][string]$File,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineStart', 'StartLine')][uint]$Line,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('Col', 'ColStart', 'ColumnStart', 'StartCol', 'StartColumn')][uint]$Column,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineEnd')][uint]$EndLine,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('ColEnd', 'ColumnEnd', 'EndCol')][uint]$EndColumn,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions notice annotation title must be in single line string!')][Alias('Header')][string]$Title
            )
            begin {}
            process {
              Write-GitHubActionsAnnotation -Type 'Notice' -Message $Message -File $File -Line $Line -Column $Column -EndLine $EndLine -EndColumn $EndColumn -Title $Title
            }
            end {
              return
            }
          }
          function Write-GitHubActionsWarning {
            [CmdletBinding(HelpUri = 'https://github.com/hugoalh-studio/ghactions-toolkit-powershell/wiki/api_function_write-githubactionswarning#Write-GitHubActionsWarning')]
            [OutputType([void])]
            param (
              [Parameter(Mandatory = $true, Position = 0, ValueFromPipelineByPropertyName = $true)][Alias('Content')][string]$Message,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions warning annotation issue file must be in single line string!')][Alias('Path')][string]$File,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineStart', 'StartLine')][uint]$Line,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('Col', 'ColStart', 'ColumnStart', 'StartCol', 'StartColumn')][uint]$Column,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('LineEnd')][uint]$EndLine,
              [Parameter(ValueFromPipelineByPropertyName = $true)][Alias('ColEnd', 'ColumnEnd', 'EndCol')][uint]$EndColumn,
              [Parameter(ValueFromPipelineByPropertyName = $true)][ValidatePattern('^.*$', ErrorMessage = 'GitHub Actions warning annotation title must be in single line string!')][Alias('Header')][string]$Title
            )
            begin {}
            process {
              Write-GitHubActionsAnnotation -Type 'Warning' -Message $Message -File $File -Line $Line -Column $Column -EndLine $EndLine -EndColumn $EndColumn -Title $Title
            }
            end {
              return
            }
          }
          Write-Host -Object (Get-GitHubActionsOidcToken)
        shell: "pwsh"
